import { AbsoluteFilePath } from "@fern-api/fs-utils";
import { Logger } from "@fern-api/logger";
import { HttpService, IntermediateRepresentation, TypeDeclaration, TypeId } from "@fern-fern/ir-sdk/api";
import {
    AsIsManager,
    CoreUtilitiesManager,
    DependencyManager,
    ExportedDirectory,
    ExportedFilePath,
    ExportsManager,
    ImportsManager,
    NpmPackage,
    PackageId,
    SimpleTypescriptProject,
    TypescriptProject
} from "@fern-typescript/commons";
import { GeneratorContext } from "@fern-typescript/contexts";
import { HonoEndpointTypeSchemasGenerator } from "@fern-typescript/hono-endpoint-type-schemas-generator";
import { HonoErrorGenerator } from "@fern-typescript/hono-error-generator";
import { HonoErrorSchemaGenerator } from "@fern-typescript/hono-error-schema-generator";
import { HonoInlinedRequestBodyGenerator } from "@fern-typescript/hono-inlined-request-body-generator";
import { HonoInlinedRequestBodySchemaGenerator } from "@fern-typescript/hono-inlined-request-body-schema-generator";
import { HonoRegisterGenerator } from "@fern-typescript/hono-register-generator";
import { HonoServiceGenerator } from "@fern-typescript/hono-service-generator";
import { GenericAPIHonoErrorGenerator } from "@fern-typescript/generic-hono-error-generators";
import { ErrorResolver, PackageResolver, TypeResolver } from "@fern-typescript/resolvers";
import { TypeGenerator } from "@fern-typescript/type-generator";
import { TypeReferenceExampleGenerator } from "@fern-typescript/type-reference-example-generator";
import { TypeSchemaGenerator } from "@fern-typescript/type-schema-generator";
import { Directory, Project, SourceFile } from "ts-morph";

import { HonoContextImpl } from "./contexts/HonoContextImpl";
import { EndpointDeclarationReferencer } from "./declaration-referencers/EndpointDeclarationReferencer";
import { HonoErrorDeclarationReferencer } from "./declaration-referencers/HonoErrorDeclarationReferencer";
import { HonoInlinedRequestBodyDeclarationReferencer } from "./declaration-referencers/HonoInlinedRequestBodyDeclarationReferencer";
import { HonoRegisterDeclarationReferencer } from "./declaration-referencers/HonoRegisterDeclarationReferencer";
import { HonoServiceDeclarationReferencer } from "./declaration-referencers/HonoServiceDeclarationReferencer";
import { GenericAPIHonoErrorDeclarationReferencer } from "./declaration-referencers/GenericAPIHonoErrorDeclarationReferencer";
import { JsonDeclarationReferencer } from "./declaration-referencers/JsonDeclarationReferencer";
import { TypeDeclarationReferencer } from "./declaration-referencers/TypeDeclarationReferencer";

const FILE_HEADER = `// This file was auto-generated by Fern from our API Definition.
`;

export declare namespace HonoGenerator {
    export interface Init {
        namespaceExport: string;
        intermediateRepresentation: IntermediateRepresentation;
        context: GeneratorContext;
        npmPackage: NpmPackage;
        config: Config;
    }

    export interface Config {
        shouldUseBrandedStringAliases: boolean;
        areImplementationsOptional: boolean;
        doNotHandleUnrecognizedErrors: boolean;
        includeUtilsOnUnionMembers: boolean;
        includeOtherInUnionTypes: boolean;
        treatUnknownAsAny: boolean;
        includeSerdeLayer: boolean;
        outputEsm: boolean;
        retainOriginalCasing: boolean;
        allowExtraFields: boolean;
        skipRequestValidation: boolean;
        skipResponseValidation: boolean;
        requestValidationStatusCode: number;
        useBigInt: boolean;
        noOptionalProperties: boolean;
        packagePath: string | undefined;
        packageManager: "pnpm" | "yarn";
        formatter: "prettier" | "biome" | "oxfmt" | "none";
        linter: "biome" | "oxlint" | "none";
        enableForwardCompatibleEnums: boolean;

        // Hono-specific
        runtime: "node" | "bun" | "deno" | "cloudflare-workers" | "edge" | "auto";
        useHonoValidator: boolean;
        useFactoryPattern: boolean;
        includeRPCTypes: boolean;
        optimizeForEdge: boolean;
    }
}

export class HonoGenerator {
    private context: GeneratorContext;
    private intermediateRepresentation: IntermediateRepresentation;
    private npmPackage: NpmPackage;
    private config: HonoGenerator.Config;

    private defaultSrcDirectory: string;
    private defaultTestDirectory: string;

    private project: Project;
    private rootDirectory: Directory;
    private exportsManager: ExportsManager;
    private dependencyManager = new DependencyManager();
    private coreUtilitiesManager: CoreUtilitiesManager;
    private typeResolver: TypeResolver;
    private errorResolver: ErrorResolver;
    private packageResolver: PackageResolver;

    private typeDeclarationReferencer: TypeDeclarationReferencer;
    private typeSchemaDeclarationReferencer: TypeDeclarationReferencer;
    private honoInlinedRequestBodyDeclarationReferencer: HonoInlinedRequestBodyDeclarationReferencer;
    private honoInlinedRequestBodySchemaDeclarationReferencer: HonoInlinedRequestBodyDeclarationReferencer;
    private honoEndpointSchemaDeclarationReferencer: EndpointDeclarationReferencer;
    private honoServiceDeclarationReferencer: HonoServiceDeclarationReferencer;
    private honoRegisterDeclarationReferencer: HonoRegisterDeclarationReferencer;
    private genericApiHonoErrorDeclarationReferencer: GenericAPIHonoErrorDeclarationReferencer;
    private honoErrorDeclarationReferencer: HonoErrorDeclarationReferencer;
    private jsonDeclarationReferencer: JsonDeclarationReferencer;
    private honoErrorSchemaDeclarationReferencer: HonoErrorDeclarationReferencer;

    private typeGenerator: TypeGenerator;
    private typeSchemaGenerator: TypeSchemaGenerator;
    private typeReferenceExampleGenerator: TypeReferenceExampleGenerator;
    private honoInlinedRequestBodyGenerator: HonoInlinedRequestBodyGenerator;
    private honoInlinedRequestBodySchemaGenerator: HonoInlinedRequestBodySchemaGenerator;
    private honoEndpointTypeSchemasGenerator: HonoEndpointTypeSchemasGenerator;
    private honoServiceGenerator: HonoServiceGenerator;
    private honoRegisterGenerator: HonoRegisterGenerator;
    private genericApiHonoErrorGenerator: GenericAPIHonoErrorGenerator;
    private honoErrorGenerator: HonoErrorGenerator;
    private honoErrorSchemaGenerator: HonoErrorSchemaGenerator;
    private readonly asIsManager: AsIsManager;
    private readonly namespaceExport: string;

    constructor({ namespaceExport, intermediateRepresentation, context, npmPackage, config }: HonoGenerator.Init) {
        this.context = context;
        this.intermediateRepresentation = intermediateRepresentation;
        this.npmPackage = npmPackage;
        this.config = config;
        this.namespaceExport = namespaceExport;

        this.defaultSrcDirectory = "src";
        this.defaultTestDirectory = "tests";

        this.exportsManager = new ExportsManager({ packagePath: config.packagePath });
        this.coreUtilitiesManager = new CoreUtilitiesManager({
            streamType: "wrapper",
            formDataSupport: "Node16",
            fetchSupport: "node-fetch",
            relativePackagePath: this.getRelativePackagePath(),
            relativeTestPath: this.getRelativeTestPath(),
            generateEndpointMetadata: false,
            customPagerName: "CustomPager"
        });
        this.asIsManager = new AsIsManager({
            useBigInt: config.useBigInt,
            generateWireTests: false,
            relativePackagePath: this.getRelativePackagePath(),
            relativeTestPath: this.getRelativeTestPath(),
            generatorType: "hono",
            formatter: config.formatter,
            linter: config.linter
        });

        this.project = new Project({
            useInMemoryFileSystem: true
        });
        this.rootDirectory = this.project.createDirectory("/");
        this.typeResolver = new TypeResolver(intermediateRepresentation);
        this.errorResolver = new ErrorResolver(intermediateRepresentation);
        this.packageResolver = new PackageResolver(intermediateRepresentation);

        const apiDirectory: ExportedDirectory[] = [
            {
                nameOnDisk: "api",
                exportDeclaration: { namespaceExport }
            }
        ];

        const schemaDirectory: ExportedDirectory[] = [
            {
                nameOnDisk: "serialization"
            }
        ];

        this.typeDeclarationReferencer = new TypeDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport
        });
        this.typeSchemaDeclarationReferencer = new TypeDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport
        });
        this.honoInlinedRequestBodyDeclarationReferencer = new HonoInlinedRequestBodyDeclarationReferencer({
            packageResolver: this.packageResolver,
            containingDirectory: apiDirectory,
            namespaceExport
        });
        this.honoInlinedRequestBodySchemaDeclarationReferencer = new HonoInlinedRequestBodyDeclarationReferencer({
            packageResolver: this.packageResolver,
            containingDirectory: schemaDirectory,
            namespaceExport
        });
        this.honoEndpointSchemaDeclarationReferencer = new EndpointDeclarationReferencer({
            packageResolver: this.packageResolver,
            containingDirectory: schemaDirectory,
            namespaceExport
        });
        this.honoServiceDeclarationReferencer = new HonoServiceDeclarationReferencer({
            packageResolver: this.packageResolver,
            containingDirectory: apiDirectory,
            namespaceExport
        });
        this.honoRegisterDeclarationReferencer = new HonoRegisterDeclarationReferencer({
            containingDirectory: [],
            namespaceExport
        });
        this.genericApiHonoErrorDeclarationReferencer = new GenericAPIHonoErrorDeclarationReferencer({
            containingDirectory: [],
            namespaceExport
        });
        this.honoErrorDeclarationReferencer = new HonoErrorDeclarationReferencer({
            containingDirectory: apiDirectory,
            namespaceExport
        });
        this.honoErrorSchemaDeclarationReferencer = new HonoErrorDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport
        });
        this.jsonDeclarationReferencer = new JsonDeclarationReferencer({
            containingDirectory: schemaDirectory,
            namespaceExport
        });

        this.typeGenerator = new TypeGenerator({
            useBrandedStringAliases: config.shouldUseBrandedStringAliases,
            includeUtilsOnUnionMembers: config.includeUtilsOnUnionMembers,
            includeOtherInUnionTypes: config.includeOtherInUnionTypes,
            includeSerdeLayer: config.includeSerdeLayer,
            retainOriginalCasing: config.retainOriginalCasing,
            noOptionalProperties: config.noOptionalProperties,
            enableInlineTypes: false,
            generateReadWriteOnlyTypes: false,
            enableForwardCompatibleEnums: config.enableForwardCompatibleEnums
        });
        this.typeSchemaGenerator = new TypeSchemaGenerator({
            includeUtilsOnUnionMembers: config.includeUtilsOnUnionMembers,
            noOptionalProperties: config.noOptionalProperties
        });
        this.typeReferenceExampleGenerator = new TypeReferenceExampleGenerator({
            useBigInt: config.useBigInt,
            includeSerdeLayer: config.includeSerdeLayer
        });
        this.honoInlinedRequestBodyGenerator = new HonoInlinedRequestBodyGenerator({});
        this.honoInlinedRequestBodySchemaGenerator = new HonoInlinedRequestBodySchemaGenerator({
            includeSerdeLayer: config.includeSerdeLayer,
            skipRequestValidation: config.skipRequestValidation,
            allowExtraFields: config.allowExtraFields
        });
        this.honoEndpointTypeSchemasGenerator = new HonoEndpointTypeSchemasGenerator({
            includeSerdeLayer: config.includeSerdeLayer,
            allowExtraFields: config.allowExtraFields,
            skipRequestValidation: config.skipRequestValidation,
            skipResponseValidation: config.skipResponseValidation
        });
        this.honoServiceGenerator = new HonoServiceGenerator({
            packageResolver: this.packageResolver,
            doNotHandleUnrecognizedErrors: config.doNotHandleUnrecognizedErrors,
            includeSerdeLayer: config.includeSerdeLayer,
            skipRequestValidation: config.skipRequestValidation,
            skipResponseValidation: config.skipResponseValidation,
            requestValidationStatusCode: config.requestValidationStatusCode
        });
        this.honoRegisterGenerator = new HonoRegisterGenerator({
            packageResolver: this.packageResolver,
            intermediateRepresentation: this.intermediateRepresentation,
            registerFunctionName: this.honoRegisterDeclarationReferencer.getRegisterFunctionName(),
            areImplementationsOptional: config.areImplementationsOptional
        });
        this.genericApiHonoErrorGenerator = new GenericAPIHonoErrorGenerator();
        this.honoErrorGenerator = new HonoErrorGenerator({
            includeSerdeLayer: config.includeSerdeLayer
        });
        this.honoErrorSchemaGenerator = new HonoErrorSchemaGenerator({
            includeSerdeLayer: config.includeSerdeLayer,
            allowExtraFields: config.allowExtraFields
        });
    }

    public async generate(): Promise<TypescriptProject> {
        this.context.logger.debug("Copying as-is files");
        await this.copyAsIsFiles();
        this.generateTypeDeclarations();
        this.generateInlinedRequestBodies();
        this.generateHonoServices();
        this.generateHonoRegister();
        this.generateGenericApiHonoGenerator();
        this.generateErrorDeclarations();

        if (this.config.includeSerdeLayer) {
            this.generateTypeSchemas();
            this.generateInlinedRequestBodySchemas();
            this.generateEndpointTypeSchemas();
            this.generateErrorSchemas();
        }

        this.coreUtilitiesManager.finalize(this.exportsManager, this.dependencyManager);
        this.exportsManager.writeExportsToProject(this.rootDirectory);

        return new SimpleTypescriptProject({
            runScripts: true,
            npmPackage: this.npmPackage,
            dependencies: this.dependencyManager.getDependencies(),
            tsMorphProject: this.project,
            outputEsm: this.config.outputEsm,
            extraDependencies: {},
            extraDevDependencies: {},
            extraFiles: {},
            extraScripts: {},
            extraPeerDependencies: {},
            extraPeerDependenciesMeta: {},
            resolutions: {},
            extraConfigs: undefined,
            outputJsr: false,
            exportSerde: false,
            useLegacyExports: true,
            packageManager: this.config.packageManager,
            testPath: this.getRelativeTestPath(),
            formatter: this.config.formatter,
            linter: this.config.linter
        });
    }

    public async copyCoreUtilities({
        pathToSrc,
        pathToRoot
    }: {
        pathToSrc: AbsoluteFilePath;
        pathToRoot: AbsoluteFilePath;
    }): Promise<void> {
        await this.coreUtilitiesManager.copyCoreUtilities({
            pathToSrc,
            pathToRoot
        });
    }

    private getTypesToGenerate(): Record<TypeId, TypeDeclaration> {
        return this.intermediateRepresentation.types;
    }

    private generateTypeDeclarations() {
        for (const typeDeclaration of Object.values(this.getTypesToGenerate())) {
            this.withSourceFile({
                filepath: this.typeDeclarationReferencer.getExportedFilepath(typeDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateHonoContext({
                        logger: this.context.logger,
                        sourceFile,
                        importsManager
                    });
                    context.type.getGeneratedType(typeDeclaration.name).writeToFile(context);
                }
            });
        }
    }

    private generateTypeSchemas() {
        for (const typeDeclaration of Object.values(this.getTypesToGenerate())) {
            this.withSourceFile({
                filepath: this.typeSchemaDeclarationReferencer.getExportedFilepath(typeDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateHonoContext({
                        logger: this.context.logger,
                        sourceFile,
                        importsManager
                    });
                    context.typeSchema.getSchemaOfNamedType(typeDeclaration.name, { isGeneratingSchema: false }).writeSchemaToFile(context);
                }
            });
        }
    }

    private generateInlinedRequestBodies() {
        for (const service of Object.values(this.intermediateRepresentation.services)) {
            for (const endpoint of service.endpoints) {
                if (endpoint.requestBody?.type === "inlinedRequestBody") {
                    this.withSourceFile({
                        filepath: this.honoInlinedRequestBodyDeclarationReferencer.getExportedFilepath({
                            packageId: service.name.fernFilepath.packagePath,
                            endpoint: endpoint.name
                        }),
                        run: ({ sourceFile, importsManager }) => {
                            const context = this.generateHonoContext({
                                logger: this.context.logger,
                                sourceFile,
                                importsManager
                            });
                            context.honoInlinedRequestBody
                                .getGeneratedInlinedRequestBody(service.name.fernFilepath.packagePath, endpoint.name)
                                .writeToFile(context);
                        }
                    });
                }
            }
        }
    }

    private generateInlinedRequestBodySchemas() {
        for (const service of Object.values(this.intermediateRepresentation.services)) {
            for (const endpoint of service.endpoints) {
                if (endpoint.requestBody?.type === "inlinedRequestBody") {
                    this.withSourceFile({
                        filepath: this.honoInlinedRequestBodySchemaDeclarationReferencer.getExportedFilepath({
                            packageId: service.name.fernFilepath.packagePath,
                            endpoint: endpoint.name
                        }),
                        run: ({ sourceFile, importsManager }) => {
                            const context = this.generateHonoContext({
                                logger: this.context.logger,
                                sourceFile,
                                importsManager
                            });
                            context.honoInlinedRequestBodySchema
                                .getGeneratedInlinedRequestBodySchema(service.name.fernFilepath.packagePath, endpoint.name)
                                .writeSchemaToFile(context);
                        }
                    });
                }
            }
        }
    }

    private generateEndpointTypeSchemas() {
        for (const service of Object.values(this.intermediateRepresentation.services)) {
            for (const endpoint of service.endpoints) {
                this.withSourceFile({
                    filepath: this.honoEndpointSchemaDeclarationReferencer.getExportedFilepath({
                        packageId: service.name.fernFilepath.packagePath,
                        endpoint: endpoint.name
                    }),
                    run: ({ sourceFile, importsManager }) => {
                        const context = this.generateHonoContext({
                            logger: this.context.logger,
                            sourceFile,
                            importsManager
                        });
                        context.honoEndpointTypeSchemas
                            .getGeneratedEndpointTypeSchemas(service.name.fernFilepath.packagePath, endpoint.name)
                            .writeToFile(context);
                    }
                });
            }
        }
    }

    private generateHonoServices() {
        for (const [serviceId, service] of Object.entries(this.intermediateRepresentation.services)) {
            this.withSourceFile({
                filepath: this.honoServiceDeclarationReferencer.getExportedFilepath({
                    serviceId,
                    service
                }),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateHonoContext({
                        logger: this.context.logger,
                        sourceFile,
                        importsManager
                    });
                    context.honoService
                        .getGeneratedHonoService(service.name.fernFilepath.packagePath)
                        .writeToFile(context);
                }
            });
        }
    }

    private generateHonoRegister() {
        this.withSourceFile({
            filepath: this.honoRegisterDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateHonoContext({
                    logger: this.context.logger,
                    sourceFile,
                    importsManager
                });
                context.honoRegister.getGeneratedHonoRegister().writeToFile(context);
            }
        });
    }

    private generateGenericApiHonoGenerator() {
        this.withSourceFile({
            filepath: this.genericApiHonoErrorDeclarationReferencer.getExportedFilepath(),
            run: ({ sourceFile, importsManager }) => {
                const context = this.generateHonoContext({
                    logger: this.context.logger,
                    sourceFile,
                    importsManager
                });
                context.genericAPIHonoError.getGeneratedGenericAPIHonoError().writeToFile(context);
            }
        });
    }

    private generateErrorDeclarations() {
        for (const errorDeclaration of Object.values(this.intermediateRepresentation.errors)) {
            this.withSourceFile({
                filepath: this.honoErrorDeclarationReferencer.getExportedFilepath(errorDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateHonoContext({
                        logger: this.context.logger,
                        sourceFile,
                        importsManager
                    });
                    context.honoError.getGeneratedHonoError(errorDeclaration.name).writeToFile(context);
                }
            });
        }
    }

    private generateErrorSchemas() {
        for (const errorDeclaration of Object.values(this.intermediateRepresentation.errors)) {
            this.withSourceFile({
                filepath: this.honoErrorSchemaDeclarationReferencer.getExportedFilepath(errorDeclaration.name),
                run: ({ sourceFile, importsManager }) => {
                    const context = this.generateHonoContext({
                        logger: this.context.logger,
                        sourceFile,
                        importsManager
                    });
                    context.honoErrorSchema.getGeneratedHonoErrorSchema(errorDeclaration.name).writeSchemaToFile(context);
                }
            });
        }
    }

    private async copyAsIsFiles(): Promise<void> {
        await this.asIsManager.copyAsIsFiles(this.rootDirectory, this.exportsManager);
    }

    private withSourceFile({
        filepath,
        run
    }: {
        filepath: ExportedFilePath;
        run: (args: { sourceFile: SourceFile; importsManager: ImportsManager }) => void;
    }): void {
        const sourceFile = this.getSourceFile(filepath);
        const importsManager = new ImportsManager({ sourceFile });
        run({ sourceFile, importsManager });
        sourceFile.insertStatements(0, FILE_HEADER);
    }

    private getSourceFile(filepath: ExportedFilePath): SourceFile {
        const directories = this.getDirectoriesForExportedFilepath(filepath);
        const filename = filepath.file.nameOnDisk;
        return directories.addSourceFile(filename);
    }

    private getDirectoriesForExportedFilepath(exportedFilepath: ExportedFilePath): Directory {
        let currentDirectory = this.getSrcDirectory();
        for (const exportedDirectory of exportedFilepath.directories) {
            currentDirectory = currentDirectory.createDirectory(exportedDirectory.nameOnDisk);
            const exportDeclaration = exportedDirectory.exportDeclaration;
            if (exportDeclaration != null) {
                this.exportsManager.addExport(currentDirectory.getPath(), exportDeclaration);
            }
        }
        const exportDeclaration = exportedFilepath.file.exportDeclaration;
        if (exportDeclaration != null) {
            this.exportsManager.addExport(
                this.getPathFromSrcToFile({ directories: currentDirectory, filename: exportedFilepath.file.nameOnDisk }),
                exportDeclaration
            );
        }
        return currentDirectory;
    }

    private getPathFromSrcToFile({ directories, filename }: { directories: Directory; filename: string }): string {
        const pathFromRoot = directories.getPath();
        const srcDirectoryPath = this.getSrcDirectory().getPath();
        return `${pathFromRoot.slice(srcDirectoryPath.length)}/${filename.replace(/\.ts$/, "")}`;
    }

    private getSrcDirectory(): Directory {
        const srcDirectory = this.rootDirectory.getDirectory(this.defaultSrcDirectory);
        if (srcDirectory != null) {
            return srcDirectory;
        }
        return this.rootDirectory.createDirectory(this.defaultSrcDirectory);
    }

    private generateHonoContext({
        logger,
        sourceFile,
        importsManager
    }: {
        logger: Logger;
        sourceFile: SourceFile;
        importsManager: ImportsManager;
    }): HonoContextImpl {
        return new HonoContextImpl({
            logger,
            sourceFile,
            importsManager,
            exportsManager: this.exportsManager,
            dependencyManager: this.dependencyManager,
            coreUtilitiesManager: this.coreUtilitiesManager,
            fernConstants: this.intermediateRepresentation.constants,
            typeResolver: this.typeResolver,
            errorResolver: this.errorResolver,
            packageResolver: this.packageResolver,
            typeDeclarationReferencer: this.typeDeclarationReferencer,
            typeSchemaDeclarationReferencer: this.typeSchemaDeclarationReferencer,
            honoInlinedRequestBodyDeclarationReferencer: this.honoInlinedRequestBodyDeclarationReferencer,
            honoInlinedRequestBodySchemaDeclarationReferencer: this.honoInlinedRequestBodySchemaDeclarationReferencer,
            honoEndpointSchemaDeclarationReferencer: this.honoEndpointSchemaDeclarationReferencer,
            honoServiceDeclarationReferencer: this.honoServiceDeclarationReferencer,
            honoRegisterDeclarationReferencer: this.honoRegisterDeclarationReferencer,
            genericApiHonoErrorDeclarationReferencer: this.genericApiHonoErrorDeclarationReferencer,
            honoErrorDeclarationReferencer: this.honoErrorDeclarationReferencer,
            honoErrorSchemaDeclarationReferencer: this.honoErrorSchemaDeclarationReferencer,
            jsonDeclarationReferencer: this.jsonDeclarationReferencer,
            typeGenerator: this.typeGenerator,
            typeSchemaGenerator: this.typeSchemaGenerator,
            typeReferenceExampleGenerator: this.typeReferenceExampleGenerator,
            honoInlinedRequestBodyGenerator: this.honoInlinedRequestBodyGenerator,
            honoInlinedRequestBodySchemaGenerator: this.honoInlinedRequestBodySchemaGenerator,
            honoEndpointTypeSchemasGenerator: this.honoEndpointTypeSchemasGenerator,
            honoServiceGenerator: this.honoServiceGenerator,
            honoRegisterGenerator: this.honoRegisterGenerator,
            genericApiHonoErrorGenerator: this.genericApiHonoErrorGenerator,
            honoErrorGenerator: this.honoErrorGenerator,
            honoErrorSchemaGenerator: this.honoErrorSchemaGenerator
        });
    }

    private getRelativePackagePath(): string {
        return this.config.packagePath ?? "";
    }

    private getRelativeTestPath(): string {
        return "tests";
    }
}
